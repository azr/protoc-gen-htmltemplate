package generator

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"path"
	"strings"

	"github.com/golang/protobuf/proto"
	"github.com/golang/protobuf/protoc-gen-go/descriptor"
	google_protobuf "github.com/golang/protobuf/protoc-gen-go/descriptor"
	plugin "github.com/golang/protobuf/protoc-gen-go/plugin"
)

//Generator will generate our template files
type Generator struct {
	*bytes.Buffer

	Request  *plugin.CodeGeneratorRequest  // The input.
	Response *plugin.CodeGeneratorResponse // The output.

	TemplateEngine string // mustache, all the time right now
}

// New creates a new generator
func New() *Generator {
	return &Generator{
		Buffer:         new(bytes.Buffer),
		Request:        new(plugin.CodeGeneratorRequest),
		Response:       new(plugin.CodeGeneratorResponse),
		TemplateEngine: "mustache",
	}
}

// Error reports a problem, including an error, and exits the program.
func (g *Generator) Error(err error, msgs ...string) {
	s := strings.Join(msgs, " ") + ":" + err.Error()
	log.Print("protoc-gen-htmltemplate: error:", s)
	os.Exit(1)
}

// Fail reports a problem and exits the program.
func (g *Generator) Fail(msgs ...string) {
	s := strings.Join(msgs, " ")
	log.Print("protoc-gen-htmltemplate: error:", s)
	os.Exit(1)
}

// GenerateAllFiles generates the output for all the files we're outputting.
func (g *Generator) GenerateAllFiles() {
	for _, fdesciptor := range g.Request.ProtoFile {
		g.Response.File = append(g.Response.File, g.GenerateFile(fdesciptor))
	}
}

// GenerateFile given a protobuf file descriptor will generate a template file
func (g *Generator) GenerateFile(fdesciptor *google_protobuf.FileDescriptorProto) *plugin.CodeGeneratorResponse_File {
	res := &plugin.CodeGeneratorResponse_File{
		Name: proto.String(fileName(*fdesciptor.Name, g.TemplateEngine)),
	}

	out := bytes.NewBufferString("// Code generated by protoc-gen-htmltemplate.")
	fmt.Fprintf(out, `
// source: %s
// DO NOT EDIT!

var templates = templates || {};

`, *fdesciptor.Name)
	for _, msgType := range fdesciptor.MessageType {
		fmt.Fprintf(out, "\ntemplates.%s = {\n", *msgType.Name)

		// render form view
		fmt.Fprintf(out, "  form : '")

		var formIncludes []string
		for _, field := range msgType.Field {
			fmt.Fprintf(out, `<div class="form-group">`)
			fmt.Fprintf(out, `<label for="%s">%s</label>`, *field.JsonName, *field.Name)

			switch *field.Type {
			case descriptor.FieldDescriptorProto_TYPE_DOUBLE,
				descriptor.FieldDescriptorProto_TYPE_FLOAT:
				fmt.Fprintf(out, `<input class="form-control" id="%s" name="%[1]s" type=number step=any >`, *field.JsonName)
			case descriptor.FieldDescriptorProto_TYPE_INT64,
				descriptor.FieldDescriptorProto_TYPE_SFIXED32,
				descriptor.FieldDescriptorProto_TYPE_SFIXED64,
				descriptor.FieldDescriptorProto_TYPE_SINT32,
				descriptor.FieldDescriptorProto_TYPE_SINT64,
				descriptor.FieldDescriptorProto_TYPE_INT32,
				descriptor.FieldDescriptorProto_TYPE_FIXED64,
				descriptor.FieldDescriptorProto_TYPE_FIXED32:
				fmt.Fprintf(out, `<input class="form-control" id="%s" name="%[1]s" type=number step=1 >`, *field.JsonName)
			case descriptor.FieldDescriptorProto_TYPE_UINT64,
				descriptor.FieldDescriptorProto_TYPE_UINT32:
				fmt.Fprintf(out, `<input class="form-control" id="%s" name="%[1]s" type=number step=1 min=0 >`, *field.JsonName)
			case descriptor.FieldDescriptorProto_TYPE_BOOL:
				fmt.Fprintf(out, `<input class="form-control" id="%s" name="%[1]s" type="checkbox" >`, *field.JsonName)
			case descriptor.FieldDescriptorProto_TYPE_STRING:
				fmt.Fprintf(out, `<input class="form-control" id="%s" name="%[1]s" type="text" >`, *field.JsonName)
			case descriptor.FieldDescriptorProto_TYPE_MESSAGE:
				n := getTypeNameName(field.GetTypeName())
				fmt.Fprintf(out, `{{> %s}}`, n)
				formIncludes = append(formIncludes, n)
			case descriptor.FieldDescriptorProto_TYPE_ENUM:
				fmt.Fprintf(out, `<select class="form-control" id="%s" name="%[1]s">`, *field.JsonName)
				fmt.Fprintf(out, `</select>`)
			case descriptor.FieldDescriptorProto_TYPE_BYTES:
				//just ignore byte arrays
			default:
				// 	descriptor.FieldDescriptorProto_TYPE_GROUP,
				g.Fail("unknown type ", field.GetName())
			}
			// fmt.Fprintf(out, `<small id="%sHelp" class="form-text text-muted">%s</small>`, *field.JsonName, ?Comment)
			fmt.Fprintf(out, `</div>`)
		}
		fmt.Fprintf(out, "',\n")
		fmt.Fprintf(out, "  formIncludes: function() { return {")
		for i, incl := range formIncludes {
			if i > 0 {
				fmt.Fprintf(out, `,`)
			}
			fmt.Fprintf(out, "%s: templates.%[1]s.form", incl)
		}

		//end of file
		fmt.Fprintf(out, "} }, \n};\n")
	}
	res.Content = proto.String(out.String())
	return res
}

// fileName returns the output name for the generated template file.
func fileName(name, engine string) string {
	if ext := path.Ext(name); ext == ".proto" || ext == ".protodevel" {
		name = name[:len(name)-len(ext)]
	}
	return name + ".pb." + engine + ".js"
}

func getTypeNameName(typeName string) (name string) {
	idx := strings.LastIndex(typeName, ".")
	if idx == -1 {
		return typeName
	}
	return typeName[idx+1:]
}
